<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WC3 Geometry</title>
    <base href="wc3-geometry">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="main.css">
    <script type="module" src="js/main.mjs" defer></script>
    <script type="module" src="js/example/axis.mjs" defer></script>
    <script type="module" src="js/example/angle.mjs" defer></script>
    <script type="module" src="js/example/distance-line.mjs" defer></script>
    <script type="module" src="js/example/distance.mjs" defer></script>
    <script type="module" src="js/example/angle-between-points.mjs" defer></script>
    <script type="module" src="js/example/polar-offset.mjs" defer></script>
    <script type="module" src="js/example/angle-normalize.mjs" defer></script>
    <script type="module" src="js/example/angle-of-rotation.mjs" defer></script>
    <script type="module" src="js/example/line-point-perpendicular.mjs" defer></script>
    <script type="module" src="js/example/line-segment-intersect.mjs" defer></script>
</head>
<body>

<h1 class="header">Геометрия в игре</h1>
<div class="container">

    <!-- Предисловие -->
    <h2 class="header">Предисловие</h2>
    <p>
        Цель этой статьи познакомить новичков с геометрией в игре. Так что не ждите здесь
        <a href="https://w.wiki/7XDe">пересечений паралельных прямых</a> и прочих интересных вещей.
        Здесь будут только базовые знания немного посыпанные формулами и объяснениями на уровне первого класа особо одарённых учеников. Так что заварите себе чаю, возьмите в зубы карандаш для умного вида и погнали.
    </p>

    <!-- Координаты -->
    <h2 id="axis" class="header">Координаты</h2>
    <p>
        Когда речь заходит о позиционировании, первым делом необходимо определить точку отсчёта. В нашем случае это
        <a href="https://w.wiki/7XDf">оси координат</a>. Даже если вы плохо учились в школе, наша наглядная демонстрация поможет вам в понимании их работы.
    </p>

    <div class="canvas canvas-axis ar-1"></div>

    <p>
        Учтите, что точка
        <span class="point"><b>0</b><b>0</b></span> не всегда находится в середине карты. При определённой криворукости, она вообще может быть за её пределами.
        Это следствие того, что при изменениии границ карты координаты не сдвигаются относительно рельефа.
    </p>

    <!-- Расстояние -->
    <h2 id="distance" class="header">Расстояние</h2>
    <p>
        Когда речь заходит о
        <a href="https://w.wiki/7Z6h">расстоянии</a>, то первым на ум приходит расстояние между двумя точками.
        Но мы не будем сходу окунаться в двумерное пространство, а ограничимся одним измерением, тобишь точками на координатной прямой.
    </p>
    <p>
        Для того, чтобы вычислить расстояние между двумя точками на координатной прямой, необходимо просто взять
        <a href="https://w.wiki/7Z79">абсолютную величину</a> разности двух ккординат. Или по простому, отнять от одной координаты другую и выбросить минус, если он есть. Притом абсолютно не важно, какую координату из какой вычитать. Убедиться в этом вы можете на интерактивной демонстрации.
    </p>

    <div class="canvas canvas-distance-line"></div>

    <p>Как вы могли заметить, формула прекрасно работает вне зависимости от направления оси. Теперь можно воспользоваться
        <a href="https://w.wiki/7axe">теоремой Пифагора</a> и найти расстояние между точками на плоскости.
    </p>

    <p>
        Если вы не понимаете, при чём здесь треугольники, то эта интерактивная демонстрация вам всё пояснит.
    </p>
    <div class="canvas canvas-distance ar-2"></div>

    <p>Как видите, у нас всегда получается треугольник <b>ABC</b>, где
        <b>AB</b> является <a href="https://w.wiki/7fU2">гипотенузой</a>. Её длину несложно вычислить по
        <a href="https://w.wiki/7axe">теореме Пифагора</a>:
        <b>AB<sup>2</sup> = AC<sup>2</sup> + BC<sup>2</sup></b>.</p>
    <pre class="canvas-distance-pre">
AC = A<sub>x</sub> - C<sub>x</sub> = <span data-v="ac">?</span>
BC = B<sub>y</sub> - C<sub>y</sub> = <span data-v="bc">?</span>
AC<sup>2</sup> + BC<sup>2</sup> = <span data-v="acbc">?</span>
AB = <i>SquareRoot</i>(AC<sup>2</sup> + BC<sup>2</sup>) = <span data-v="ab">?</span></pre>

    <h3>Вычисление в игре</h3>
    <p>В файле
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/7ee48312a9c68dd27b810054fa11c3c986178fea/sdk/blizzard.j#L762">blizzard.j</a> находится специально обученная функция:
    </p>
    <pre>function DistanceBetweenPoints takes location locA, location locB returns real
    local real dx = GetLocationX(locB) - GetLocationX(locA)
    local real dy = GetLocationY(locB) - GetLocationY(locA)
    return SquareRoot(dx * dx + dy * dy)
endfunction</pre>
    <p>
        Если же вы являетесь счастливым обладателем
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource">UjAPI</a>, то можете воспользоваться следующими нативками:
    </p>
    <pre>
native MathDistanceBetweenPoints takes real fromX, real fromY, real toX, real toY returns real
native MathDistanceBetweenLocations takes location fromLoc, location toLoc returns real
</pre>

    <!-- Углы -->
    <h2 id="angles" class="header">Углы</h2>
    <p>Когда речь заходит про измерение <a href="https://w.wiki/7YCN">углов</a>, те, кто учился в школе сразу вспоминают
        <a href="https://w.wiki/7YBq">транспортир</a> и разметку
        <a href="https://w.wiki/7YBv">от нуля до 360</a>. Это всё прекрасно работает в своей области применения, но когда дело доходит до программирования то все культурные люди переходят на
        <a href="https://w.wiki/7YCS">радианы</a>. Они имеют много интересных и полезных геометрических свойств из-за чего в большинстве
        <a href="https://w.wiki/68GR">языков программирования</a> геометрические функции принимают на вход именно
        <a href="https://w.wiki/7YCS">радианы</a>.
    </p>

    <p>Для простоты понимания, по сложившейся традиции, наша команда подготовила интерактивную демонстрацию.</p>

    <div class="canvas canvas-angle ar-1"></div>

    <p>
        Чтобы не запутаться в единицах измерения будет очень полезно запомнить их обозначения:
    </p>
    <ul>
        <li>Градусы - Degrees - deg</li>
        <li>Радианы - Radians - rad</li>
    </ul>
    <h3>Получение в игре</h3>
    <p>В ваниле получить угол можно только у юнита.</p>
    <pre>constant native GetUnitFacing takes unit whichUnit returns real</pre>
    <p>В
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource">UjAPI</a>, есстественно, функций будет немного больше.
    </p>
    <pre>constant native GetUnitFacing takes unit whichUnit returns real
native GetDoodadFacing takes doodad whichDoodad returns real
native GetSpecialEffectFacing takes effect whichEffect returns real
native GetTrackableFacing takes trackable whichTrackable returns real
native GetWidgetFacing takes widget whichWidget returns real
native GetDestructableFacing takes destructable whichDestructable returns real
native GetItemFacing takes item whichItem returns real
native GetProjectileFacing takes projectile whichProjectile returns real
native GetFrameSpriteFacing takes framehandle whichFrame returns real</pre>
    <p>Все эти функции возвращают угол в градусах в диапазоне
        <b>0 ... 360</b>. Чтобы перевести их в радианы, можете просто умножить их на константу
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/7ee48312a9c68dd27b810054fa11c3c986178fea/sdk/blizzard.j#L18C24-L18C35">bj_DEGTORAD</a> или воспользоваться следующей нативкой из
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource">UjAPI</a>.
    </p>
    <pre>native Deg2Rad takes real degrees returns real</pre>

    <!-- Угол между двумя точками -->
    <h2 id="angle-between-points" class="header">Угол между двумя точками</h2>
    <p>Как вы наверное догадались, у <a href="https://w.wiki/7dRv">точек</a> нет такого свойства как
        <a href="https://w.wiki/7YCN">угол</a>. Под этим обычно понимают минимальный угол между
        <a href="https://w.wiki/7dSH">векторами</a>. Если быть точнее, то минимальный угол, на который нужно повернуть вектор, чтоб он был сонаправлен с осью
        <b>X</b>. Звучит конечно слишком умно, поэтому смотрите на интерактивную демонстрацию и читайте объяснение ниже.
    </p>

    <div class="canvas canvas-angle-between-points ar-1"></div>

    <p>Попытаемся вычислить угол <b>AB</b>, тобишь найти минимальный угол, на который необходимо повернуть точку
        <b>B</b> вокруг точки <b>A</b> так, чтобы <b>AB</b> совпал с <b>AB2</b>.</p>

    <p>Сместим <b>AB</b> таким образом, чтоб
        <b>A</b> совпала с началом координат. Это несложно. Просто разместим там точку <b>A1</b>.</p>

    <p>Разместим точку <b>B1</b> относительно <b>A1</b> таким же образом, как и
        <b>B</b> находится относительно <b>A</b>. Если вы внимательно посмотрите на
        <a href="#angle-between-points">интерактивный пример</a> то быстро догадаетесь как это сделать:<br>
    <pre class="canvas-angle-between-points-pre-diff">B1<sub>x</sub> = B<sub>x</sub> - A<sub>x</sub> = <span data-v="bx">?</span>
B1<sub>y</sub> = B<sub>y</sub> - A<sub>y</sub> = <span data-v="by">?</span></pre>

    <p>Ну и в завершении, нам нужно вычислить
        <a href="https://w.wiki/7eeV">арктангенс</a> с помощью функции
        <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2">Atan2</a>.
    </p>
    <p>
        <a href="https://w.wiki/7eeV">Арктангенс</a> — это угол между осью
        <b>X</b> и линией, проведенной из начала координат
        <span class="point"><b>0</b><b>0</b></span> в точку с координатами
        <span class="point"><b>x</b><b>y</b></span>. Угол определяется в радианах в диапазоне от <b>-𝜋</b> до
        <b>𝜋</b>, исключая <b>-𝜋</b>.
    </p>

    <p>Так, как мы уже переместили <b>A</b> в
        <span class="point"><b>0</b><b>0</b></span>, то нам остаётся только передать координаты <b>B1</b> в функцию:</p>
    <pre class="canvas-angle-between-points-pre-angle"><i>Atan2</i>(B1<sub>y</sub>, B1<sub>x</sub>) = <span data-v="a">?</span></pre>

    <h4>Вычисление в игре</h4>
    <p>В файле
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/bc7d0c95a78c49dde28148c38290d9995e5b108a/sdk/blizzard.j#L757">blizzard.j</a> есть специально обученная функция.
    </p>
    <pre>function AngleBetweenPoints takes location locA, location locB returns real
    return bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
endfunction</pre>
    <p>Для счастливых обладателей
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource">UjAPI</a> были добавлены следуюшие нативки.
    </p>
    <pre>native MathAngleBetweenPoints takes real fromX, real fromY, real toX, real toY returns real
native MathAngleBetweenLocations takes location fromLoc, location toLoc returns real</pre>
    <p>Все вышеперечисленные функции возвращают угол в градусах в диапазоне
        <b>-180 ... 180</b>, с чем не очень удобно работать. Поэтому напишем свою функцию:</p>
    <pre>function AngleBetweenXY takes real xa, real ya, real xb, real yb returns real
    return Atan2(by - ay, bx - ax)
endfunction</pre>

    <!-- Полярное смещение -->
    <h2 id="polar-offset" class="header">Полярное смещение</h2>
    <p>
        <a href="https://w.wiki/6ML2">Полярная система координат</a> не так сложна в понимании. В отличие от
        <a href="https://w.wiki/7fUE">прямоугольной системы координат</a>, точка обозначается не через две координаты, а через
        <a href="#distance">расстояние</a> и
        <a href="#angle-between-points">угол</a>.
    </p>
    <p>Из всех возможных применений такой системы мы расмотрим только полярное смещение. Тобишь способ, как сместить точку на определённое расстояние под определённым углом.</p>

    <p>Для лучшего понимания интерактивная демонстрация к вашим услугам.</p>

    <div class="canvas canvas-polar-offset ar-1"></div>

    <p>Чтоб лишний раз не повторяться допустим, что <a href="#distance">расстояние</a> (<b>len</b>) и
        <a href="#distance">угол</a> (<b>rad</b>) <b>AB</b> мы уже вычислили и наша задача сместить точку
        <b>B</b> в точку <b>B2</b> на то же расстояние под тем же углом.</p>

    <p>Здесь нам опять понадобится смещение <b>A</b> в
        <span class="point"><b>0</b><b>0</b></span>. Можно воспользоваться способом, который мы применяли при
        <a href="#angle-between-points">вычислении углов</a>:</p>

    <pre><b>B1</b><sub>x</sub> = <b>B</b><sub>x</sub> - <b>A</b><sub>x</sub>
<b>B1</b><sub>y</sub> = <b>B</b><sub>y</sub> - <b>A</b><sub>y</sub></pre>

    <p>Хоть этот способ и прост, но он не позволяет нам изменять угол. Вот здесь на помощь приходит
        <a href="https://w.wiki/6ML2">полярная система координат</a>. Чтоб найти точку, лежащую на расстоянии (<b>len</b>) под углом (<b>rad</b>) от
        <span class="point"><b>0</b><b>0</b></span> нужно воспользоваться формулой:</p>

    <pre><b>B1</b><sub>x</sub> = <i>Cos</i>(<b>rad</b>) * <b>len</b>
<b>B1</b><sub>y</sub> = <i>Sin</i>(<b>rad</b>) * <b>len</b></pre>

    <p>Чтоб нить разговора не потерялась, напомню, что иы смещаем точку <b>B</b> в точку <b>B2</b> на расстояние
        <b>len</b> под углом <b>rad</b>. На данный момент мы получили точку <b>B1</b>, которая находится на расстоянии
        <b>len</b> под углом <b>rad</b> от <span class="point"><b>0</b><b>0</b></span>. И если прибавить к точке
        <b>B1</b> координаты <b>B</b>, то мы получим точку <b>B2</b>, которая находится на расстоянии
        <b>len</b> под углом <b>rad</b> от <b>B</b>.</p>

    <p>Запишем итоговую формулу:</p>
    <pre><b>B2</b><sub>x</sub> = <i>Cos</i>(<b>rad</b>) * <b>len</b> + <b>B</b><sub>x</sub>
<b>B2</b><sub>y</sub> = <i>Sin</i>(<b>rad</b>) * <b>len</b> + <b>B</b><sub>y</sub></pre>

    <h3>Вычисление в игре</h3>
    <p>
        В файле
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/bc7d0c95a78c49dde28148c38290d9995e5b108a/sdk/blizzard.j#L769">blizzard.j</a> вы можете найти функцию:
    </p>
    <pre>function PolarProjectionBJ takes location source, real dist, real angle returns location
    local real x = GetLocationX(source) + dist * Cos(angle * bj_DEGTORAD)
    local real y = GetLocationY(source) + dist * Sin(angle * bj_DEGTORAD)
    return Location(x, y)
endfunction</pre>
    <p>Она принимает угол в градусах, и создаёт <b>Location</b>, который нужно потом уничтожать во избежание утечек.</p>

    <p>В <a href="https://xgm.guru/p/ujapi/UjAPI-Resource">UjAPI</a> тоже есть функции:</p>

    <pre>native MathPointProjectionX takes real x, real angle, real distance returns real
native MathPointProjectionY takes real y, real angle, real distance returns real</pre>

    <p>Но они так же принимают угол в градусах, что не очень хорошо для ментального здоровья. Посему мы напишем собственные функции с блэкджеком и радианами:</p>
    <pre>function PolarProjectionX takes real x, real dist, real angle returns real
    return Cos(angle) * dist + x
endfunction
function PolarProjectionY takes real y, real dist, real angle returns real
    return Sin(angle) * dist + y
endfunction</pre>

    <!-- Нормализация угла -->
    <h2 id="angle-normalize" class="header">Нормализация угла</h2>
    <p>
        В нашем случае нормализация это приведение любого значения угла в диапазон от <b>-𝜋</b> до
        <b>𝜋</b>, исключая <b>-𝜋</b>.
    </p>
    <h3>Вычисление в игре</h3>
    <p>Для нормализации угла функций никто не завёз, поэтому мы напишем её руками:</p>

    <pre>function AngleNormalize takes real angle return real
    if angle > -bj_PI and angle <= bj_PI then
        return angle
    endif
    set angle = ModuloReal(angle + bj_PI, bj_PI * 2)
    if angle < 0 then
        return angle + bj_PI
    else
        return angle - bj_PI
    endif
endfunction</pre>

    <h4>Зачем это нужно?</h4>
    <p>
        Нормализвция редкая штука, но именно здесь логичней всего о ней рассказать пока не забылись знания о
        <a href="#polar-offset">полярном смещении</a>.
    </p>
    <div class="canvas canvas-angle-normalize ar-1"></div>
    <p>
        Рассмотрим бытовую ситуацию - вам нужно нарисовать пентаграму с центром в точке `<b>A</b>` и одним из лучей в точке `<b>B</b>.
        Простейшим решением будет найти между лучами, в нашем случае это <b>2𝜋/5</b>, и с помощью
        <a href="#polar-offset">полярного смещения</a> нарисовать остальные лучи.
    </p>

    <p>Так как мы уже умеем <a href="#distance">вычислять расстояние</a>, то осталось только посчитать углы:</p>
    <pre><b>AB1</b> = 1 * 2𝜋/5 + <b>AB</b>
<b>AB2</b> = 2 * 2𝜋/5 + <b>AB</b>
<b>AB3</b> = 3 * 2𝜋/5 + <b>AB</b>
<b>AB4</b> = 4 * 2𝜋/5 + <b>AB</b></pre>
    <p>
        Как видите, у некоторых значений углов точек
        <b>B<sup>*</sup></b> запредельные значения. Для проверки мы отрисовали точки
        <b>C<sup>*</sup></b> под нормализированным углом.
    </p>

    <!-- Угол поворота -->
    <h2 id="angle-of-rotation" class="header">Угол поворота</h2>
    <p>Угол поворота — это минимальный угол, на который нужно повернуть луч, исходящий из точки
        <b>O</b>, чтобы он совпал с другим лучом, исходящим из этой же точки.</p>

    <div class="canvas-text">
        <div>ЛКМ - Установить <b>A</b></div>
        <div>ПКМ - Установить <b>B</b></div>
    </div>
    <div class="canvas canvas-angle-of-rotation ar-2"></div>

    <p>Из точки <b>A</b> исходят два луча: <b>AB</b> и <b>AC</b>. Углом пороврота <b>D</b> для угла
        <b>AB</b> по отношению к <b>AC</b> будет такое значение, при котором <b>AB + D = AB1 = AC</b>.</p>

    <p>Если присмотритесь к интерактивной демонстрации, то можете заметить, что в некоторых случаях числовые значения
        <b>AB1</b> и
        <b>AC</b> отличаются. Если вам нужен угол в диапазоне от <b>-𝜋</b> до
        <b>𝜋</b>, исключая <b>-𝜋</b>, то можете его <a href="#angle-normalize">нормализовать</a>.</p>


    <h3>Зачем это нужно?</h3>
    <p>По знаку <b>D</b> можно определить, в какую сторону поворачивать угол. Отрицательный
        <b>D</b> - по часовой стрелке. Положительный - против.</p>

    <p>Если взять <a href="https://w.wiki/7Z79">абсолютное значение</a>
        <b>D</b>, то можно определить, принадлежит ли угол <b>AC</b>
        <a href="https://w.wiki/7kah">сектору окружности</a>.</p>


    Как обычно, функций для работы с углами не завезли, поэтому пользуемся собственной функцией:
    <pre>function AngleOfRotation takes real a, real b returns real
    local real d = b - a
    if d > bj_PI then
        return -(2 * bj_PI - d)
    elseif d < -bj_PI then
        return 2 * bj_PI + d
    endif
    return d
endfunction</pre>

    <!-- Перпендикуляр из точки к прямой -->
    <h2 id="line-point-perpendicular" class="header">Перпендикуляр из точки к прямой</h2>
    <p>Для всевозможных кастов по прямой зачастую используют всевозможные алгоритмы разной степени унылости. Пора прекратить это безобразие.</p>

    <div class="canvas-text">
        <div>ЛКМ - Установить <b>A</b></div>
        <div>ПКМ - Установить <b>B</b></div>
    </div>
    <div class="canvas canvas-line-point-perpendicular ar-1"></div>

    <p>В данном примере у нас есть прямая, заданная двумя точками <b>A</b>, <b>B</b> и точка
        <b>С</b>. Функция, приведённая ниже вычислит точку <b>С1</b>, которая является кратчайшим расстоянием от прямой
        <b>AB</b> до точки <b>C</b>.</p>

    <h3>Вычисление в игре</h3>
    <p>Как вы уже наверно догадались, разработчикам абсолютно наплевать на геометрию и функции придётся писать руками:</p>
    <pre>globals
   real LinePointPerpendicularX = 0
   real LinePointPerpendicularY = 0
endglobals

function LinePointPerpendicular takes real xa, real ya, real xb, real yb, real px, real py returns nothing
    local real m
    local real c
    local real mPerpendicular
    local real cPerpendicular

    // Прямая, паралельная оси X
    if ya == yb then
        set LinePointPerpendicularX = px
        set LinePointPerpendicularY = ya
        return
    endif

    // Прямая, паралельная оси Y
    if xa == xb then
        set LinePointPerpendicularX = xa
        set LinePointPerpendicularY = py
        return
    endif

    set m = (yb - ya) / (xb - xa) // Находим угловой коэффициент прямой AB
    set c = ya - m * xa // Находим свободный член c уравнения прямой AB
    set mPerpendicular = -1 / m // Находим угловой коэффициент перпендикулярной прямой
    set cPerpendicular = py - mPerpendicular * px // Находим свободный член c уравнения перпендикулярной прямой, проходящей через точку (x, y)

    // Находим точку пересечения перпендикулярной прямой с прямой AB
    set LinePointPerpendicularX = (cPerpendicular - c) / (m - mPerpendicular)
    set LinePointPerpendicularY = m * xIntersection + c
endfunction</pre>

    <p>Данная функция принимает координаты двух точек, обозначающих прямую <b>xa</b>, <b>ya</b>, <b>xb</b>,
        <b>yb</b>, координаты точки <b>px</b>,
        <b>py</b> и станавливает в глобальных переменных координаты искомой точки.</p>

    <p>Далее вы можете воспользоваться нативкой, которая учитывает коллизию юнита:</p>
    <pre>constant native IsUnitInRangeXY takes unit whichUnit, real x, real y, real distance returns boolean</pre>

    <p>Или же просто вычислить
        <a href="#distance">расстояние</a> и использовать его в своих целях. Только не забывайте, что прямая бесконечна и вам может понадобиться
        <a href="#angle-of-rotation">угол поворота</a>.</p>

    <!-- Пересечение отрезков -->
    <h2 id="line-segment-intersect" class="header">Пересечение отрезков</h2>
    <p>Для работы с молниями, и прочими прямыми, может понадобиться найти их пересечения чтоб заклинания не выглядели уныло. </p>
    <div class="canvas-text">
        <div>ЛКМ - Установить <b>A</b></div>
        <div>ПКМ - Установить <b>B</b></div>
        <div>ЦКМ - Установить <b>C</b></div>
        <div class="canvas-line-segment-intersect-text"></div>
    </div>
    <div class="canvas canvas-line-segment-intersect ar-1"></div>

    <h3>Вычисление в игре</h3>
    <p>Чем дальше в лес, тем толще партизаны и всё яростней разработчики доказывают, что функции для работы с геометрией придётся писать руками:</p>
    <pre>globals
    real LineSegmentIntersectX = 0
    real LineSegmentIntersectY = 0
    boolean LineSegmentIntersectA = false
    boolean LineSegmentIntersectB = false
endglobals

function LineSegmentIntersect takes real ax, real ay, real bx, real by, real cx, real cy, real dx, real dy returns boolean
    local real a
    local real b
    local real na
    local real nb
    local real d = (dy - cy) * (bx - ax) - (dx - cx) * (by - ay)

    set LineSegmentIntersectX = 0
    set LineSegmentIntersectY = 0
    set LineSegmentIntersectA = false
    set LineSegmentIntersectB = false

    if d == 0 then
        return false
    endif

    set a = ay - cy
    set b = ax - cx
    set na = (dx - cx) * a - (dy - cy) * b
    set nb = (bx - ax) * a - (by - ay) * b
    set a = na / d
    set b = nb / d

    LineSegmentIntersectX = ax + a * (bx - ax)
    LineSegmentIntersectY = ay + a * (by - ay)

    // Находится ли точка пересечения на первом отрезке
    LineSegmentIntersectA = a > 0 and a < 1

    // Находится ли точка пересечения на втором отрезке
    LineSegmentIntersectB = b > 0 and b < 1

    return true
endfunction</pre>

    <p>Функция принимает восемь аргументов с координатами четырёх точек задающих два отрезка и возвращает логическую, указывающую пересекаются ли прямые в одной и только одной точке.
        При этом в глобалках устанавливаются точка пересечения и находится ли точка пересечения на каждом отрезке.</p>

    <p>Подозреваю, что вы можете запутаться, в каком порядке передавать аргументы. Посему объясню на примере точек из кропотливо сделаной интерактивной демонстрации:</p>
    <pre><b>A<sub>x</sub></b> <b>A<sub>y</sub></b> <b>B<sub>x</sub></b> <b>B<sub>y</sub></b> <b>C<sub>x</sub></b> <b>C<sub>y</sub></b> <b>D<sub>x</sub></b> <b>D<sub>y</sub></b></pre>
    <p>В таком случае <b>LineSegmentIntersectA</b> будет указывать, лежит ли точка пересечения на отрезке
        <b>AB</b> и соответственно <b>LineSegmentIntersectB</b> на <b>CD</b>.</p>

</div>

</body>
</html>
