<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>WC3 Geometry</title>
    <base href="wc3-geometry">
    <link rel="stylesheet" href="main.css">
    <script type="module" src="js/example/axis.mjs" defer></script>
    <script type="module" src="js/example/angle.mjs" defer></script>
    <script type="module" src="js/example/distance-line.mjs" defer></script>
    <script type="module" src="js/example/distance.mjs" defer></script>
    <script type="module" src="js/example/angle-between-points.mjs" defer></script>
</head>
<body>

<h1 class="header">Геометрия в игре</h1>
<div class="container">

    <!-- Предисловие -->
    <h2 class="header">Предисловие</h2>
    <p>
        Цель этой статьи познакомить новичков с геометрией в игре. Так что не ждите здесь
        <a href="https://w.wiki/7XDe" target="_blank">пересечений паралельных прямых</a> и прочих интересных вещей.
        Здесь будут только базовые знания немного посыпанные формулами и объяснениями на уровне первого класа особо одарённых учеников. Так что заварите себе чаю, возьмите в зубы карандаш для умного вида и погнали.
    </p>

    <!-- Координаты -->
    <h2 id="axis" class="header">Координаты</h2>
    <p>
        Когда речь заходит о позиционировании, первым делом необходимо определить точку отсчёта. В нашем случае это
        <a href="https://w.wiki/7XDf">оси координат</a>. Даже если вы плохо учились в школе, наша наглядная демонстрация поможет вам в понимании их работы.
    </p>

    <div class="canvas canvas-axis"></div>

    <p>
        Учтите, что точка
        <span class="point"><b>0</b><b>0</b></span> не всегда находится в середине карты. При определённой криворукости, она вообще может быть за её пределами.
        Это следствие того, что при изменениии границ карты координаты не сдвигаются относительно рельефа.
    </p>

    <!-- Координаты -->
    <h2 id="distance" class="header">Расстояние</h2>
    <p>
        Когда речь заходит о
        <a href="https://w.wiki/7Z6h" target="_blank">расстоянии</a>, то первым на ум приходит расстояние между двумя точками.
        Но мы не будем сходу окунаться в двумерное пространство, а ограничимся одним измерением, тобишь точками на координатной прямой.
    </p>
    <p>
        Для того, чтобы вычислить расстояние между двумя точками на координатной прямой, необходимо просто взять
        <a href="https://w.wiki/7Z79" target="_blank">абсолютную величину</a> разности двух ккординат. Или по простому, отнять от одной координаты другую и выбросить минус, если он есть. Притом абсолютно не важно, какую координату из какой вычитать. Убедиться в этом вы можете на интерактивной демонстрации.
    </p>

    <div class="canvas canvas-distance-line"></div>

    <p>Как вы могли заметить, формула прекрасно работает вне зависимости от направления оси. Теперь можно воспользоваться
        <a href="https://w.wiki/7axe" target="_blank">теоремой Пифагора</a> и найти расстояние между точками на плоскости.
    </p>

    <p>
        Если вы не понимаете, при чём здесь треугольники, то эта интерактивная демонстрация вам всё пояснит.
    </p>
    <div class="canvas canvas-distance"></div>

    <p>Как видите, у нас всегда получается треугольник <b>ABC</b>, где
        <b>AB</b> является гипотенузой. Её длину несложно вычислить по
        <a href="https://w.wiki/7axe" target="_blank">теореме Пифагора</a>:
        <b>AB<sup>2</sup> = AC<sup>2</sup> + BC<sup>2</sup></b>.</p>
    <pre class="canvas-distance-pre">
AC = A<sub>x</sub> - C<sub>x</sub> = <span data-v="ac">?</span>
BC = B<sub>y</sub> - C<sub>y</sub> = <span data-v="bc">?</span>
AC<sup>2</sup> + BC<sup>2</sup> = <span data-v="acbc">?</span>
AB = <i>SquareRoot</i>(AC<sup>2</sup> + BC<sup>2</sup>) = <span data-v="ab">?</span></pre>

    <h3>Вычисление в игре</h3>
    <p>В файле
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/7ee48312a9c68dd27b810054fa11c3c986178fea/sdk/blizzard.j#L762" target="_blank">blizzard.j</a> находится специально обученная функция:
    </p>
    <pre>function DistanceBetweenPoints takes location locA, location locB returns real
    local real dx = GetLocationX(locB) - GetLocationX(locA)
    local real dy = GetLocationY(locB) - GetLocationY(locA)
    return SquareRoot(dx * dx + dy * dy)
endfunction</pre>
    <p>
        Если же вы являетесь счастливым обладателем
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource" target="_blank">UjAPI</a>, то можете воспользоваться следующими нативками:
    </p>
    <pre>
native MathDistanceBetweenPoints takes real fromX, real fromY, real toX, real toY returns real
native MathDistanceBetweenLocations takes location fromLoc, location toLoc returns real
</pre>

    <!-- Углы -->
    <h2 id="angles" class="header">Углы</h2>
    <p>Когда речь заходит про измерение <a href="https://w.wiki/7YCN">углов</a>, те, кто учился в школе сразу вспоминают
        <a href="https://w.wiki/7YBq" target="_blank">транспортир</a> и разметку
        <a href="https://w.wiki/7YBv" target="_blank">от нуля до 360</a>. Это всё прекрасно работает в своей области применения, но когда дело доходит до программирования то все культурные люди переходят на
        <a href="https://w.wiki/7YCS" target="_blank">радианы</a>. Они имеют много интересных и полезных геометрических свойств из-за чего в большинстве
        <a href="https://w.wiki/68GR" target="_blank">языков программирования</a> геометрические функции принимают на вход именно
        <a href="https://w.wiki/7YCS" target="_blank">радианы</a>.
    </p>

    <p>Для простоты понимания, по сложившейся традиции, наша команда подготовила интерактивную демонстрацию.</p>

    <div class="canvas canvas-angle"></div>

    <p>
        Чтобы не запутаться в единицах измерения будет очень полезно запомнить их обозначения:
    </p>
    <ul>
        <li>Градусы - Degrees - deg</li>
        <li>Радианы - Radians - rad</li>
    </ul>
    <h3>Получение в игре</h3>
    <p>В ваниле получить угол можно только у юнита.</p>
    <pre>constant native GetUnitFacing takes unit whichUnit returns real</pre>
    <p>В
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource" target="_blank">UjAPI</a>, есстественно, функций будет немного больше.
    </p>
    <pre>constant native GetUnitFacing takes unit whichUnit returns real
native GetDoodadFacing takes doodad whichDoodad returns real
native GetSpecialEffectFacing takes effect whichEffect returns real
native GetTrackableFacing takes trackable whichTrackable returns real
native GetWidgetFacing takes widget whichWidget returns real
native GetDestructableFacing takes destructable whichDestructable returns real
native GetItemFacing takes item whichItem returns real
native GetProjectileFacing takes projectile whichProjectile returns real
native GetFrameSpriteFacing takes framehandle whichFrame returns real</pre>
    <p>Все эти функции возвращают угол в градусах в диапазоне
        <b>0 ... 360</b>. Чтобы перевести их в радианы, можете просто умножить их на константу
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/7ee48312a9c68dd27b810054fa11c3c986178fea/sdk/blizzard.j#L18C24-L18C35" target="_blank">bj_DEGTORAD</a> или воспользоваться следующей нативкой из
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource" target="_blank">UjAPI</a>.
    </p>
    <pre>native Deg2Rad takes real degrees returns real</pre>

    <!-- Угол между двумя точками -->
    <h3 id="angle-between-points">Угол между двумя точками</h3>
    <p>Как вы наверное догадались, у <a href="https://w.wiki/7dRv" target="_blank">точек</a> нет такого свойства как
        <a href="https://w.wiki/7YCN" target="_blank">угол</a>. Под этим обычно понимают минимальный угол между
        <a href="https://w.wiki/7dSH" target="_blank">векторами</a>. Если быть точнее, то минимальный угол, на который нужно повернуть вектор, чтоб он был сонаправлен с осью
        <b>X</b>. Звучит конечно слишком умно, поэтому смотрите на интерацтивную демонстрацию и читайте объяснение ниже.
    </p>

    <div class="canvas canvas-angle-between-points"></div>

    <p>Попытаемся вычислить угол <b>AB</b>, тобишь найти минимальный угол, на который необходимо повернуть точку
        <b>B</b> вокруг точки <b>A</b> так, чтобы <b>AB</b> совпал с <b>AB2</b>.</p>

    <p>Сместим <b>AB</b> таким образом, чтоб
        <b>A</b> совпала с началом координат. Это несложно. Просто разместим там точку <b>A1</b>.</p>

    <p>Разместим точку <b>B1</b> относительно <b>A1</b> таким же образом, как и
        <b>B</b> находится относительно <b>A</b>. Если вы внимательно посмотрите на
        <a href="#angle-between-points">интерактивный пример</a> то быстро догадаетесь как это сделать:<br>
    <pre class="canvas-angle-between-points-pre-diff">B1<sub>x</sub> = B<sub>x</sub> - A<sub>x</sub> = <span data-v="bx">?</span>
B1<sub>y</sub> = B<sub>y</sub> - A<sub>y</sub> = <span data-v="by">?</span></pre>

    <p>Ну и в завершении, нам нужно вычислить
        <a href="https://w.wiki/7eeV" target="_blank">арктангенс</a> с помощью функции
        <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2" target="_blank">Atan2</a>.
    </p>
    <p>
        <a href="https://w.wiki/7eeV" target="_blank">Арктангенс</a> — это угол между осью
        <b>X</b> и линией, проведенной из начала координат
        <span class="point"><b>0</b><b>0</b></span> в точку с координатами
        <span class="point"><b>x</b><b>y</b></span>. Угол определяется в радианах в диапазоне от <b>-𝜋</b> до
        <b>𝜋</b>, исключая <b>-𝜋</b>.
    </p>

    <p>Так, как мы уже переместили <b>A</b> в
        <span class="point"><b>0</b><b>0</b></span>, то нам остаётся только передать координаты <b>B1</b> в функцию:</p>
    <pre class="canvas-angle-between-points-pre-angle"><i>Atan2</i>(B1<sub>y</sub>, B1<sub>x</sub>) = <span data-v="a">?</span></pre>

    <h4>Вычисление в игре</h4>
    <p>В файле
        <a href="https://github.com/nazarpunk/wc3-ujapi/blob/bc7d0c95a78c49dde28148c38290d9995e5b108a/sdk/blizzard.j#L757" target="_blank">blizzard.j</a> есть специально обученная функция.
    </p>
    <pre>function AngleBetweenPoints takes location locA, location locB returns real
    return bj_RADTODEG * Atan2(GetLocationY(locB) - GetLocationY(locA), GetLocationX(locB) - GetLocationX(locA))
endfunction</pre>
    <p>Для счастливых обладателей
        <a href="https://xgm.guru/p/ujapi/UjAPI-Resource" target="_blank">UjAPI</a> были добавлены следуюшие нативки.
    </p>
    <pre>native MathAngleBetweenPoints takes real fromX, real fromY, real toX, real toY returns real
native MathAngleBetweenLocations takes location fromLoc, location toLoc returns real</pre>
    <p>Все вышеперечисленные функции возвращают угол в градусах в диапазоне <b>-180 ... 180</b>, с чем не очень удобно работать. Поэтому напишем свою функцию:</p>
    <pre>function AngleBetweenXY takes real xa, real ya, real xb, real yb returns real
    return Atan2(by - ay, bx - ax)
endfunction</pre>

</div>

</body>
</html>
